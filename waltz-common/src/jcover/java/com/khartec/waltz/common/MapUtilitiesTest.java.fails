package com.khartec.waltz.common;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.collection.IsCollectionWithSize.hasSize;
import static org.hamcrest.core.Is.is;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;

import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import org.mockito.Mockito;

/**
 * Unit tests for com.khartec.waltz.common.MapUtilities
 *
 * @author Diffblue Cover
 */

class MapUtilitiesTest {

    @Test
    void newHashMap() {
        assertThat(MapUtilities.<String, String>newHashMap("HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5").get("HmacMD5"), is("HmacMD5"));
        assertThat(MapUtilities.<String, String>newHashMap("HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5").get("HmacMD5"), is("HmacMD5"));
        assertThat(MapUtilities.<String, String>newHashMap("HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5").get("HmacMD5"), is("HmacMD5"));
        assertThat(MapUtilities.<String, String>newHashMap("HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5").get("HmacMD5"), is("HmacMD5"));
        assertThat(MapUtilities.<String, String>newHashMap("HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5", "HmacMD5").get("HmacMD5"), is("HmacMD5"));
        assertThat(MapUtilities.<String, String>newHashMap("key", "HmacMD5").get("key"), is("HmacMD5"));
        assertThat(MapUtilities.<String, String>newHashMap().isEmpty(), is(true));
    }

    @Test
    void groupByXsIsFooReturnsFoo() {
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        when(keyFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        LinkedList<String> xs = new LinkedList<String>();
        xs.add("foo");
        assertThat(MapUtilities.<String, String>groupBy(keyFn, xs).get("foo"), hasSize(1));
        assertTrue(MapUtilities.<String, String>groupBy(keyFn, xs).get("foo").contains("foo"));
    }

    @Test
    void indexBy3() {
        LinkedList<String> xs = new LinkedList<String>();
        xs.add("foo");
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        when(keyFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        assertThat(MapUtilities.<String, String>indexBy(xs, keyFn).get("foo"), is("foo"));
    }

    @Test
    void indexBy4() {
        LinkedList<String> xs = new LinkedList<String>();
        xs.add("foo");
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        when(keyFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        @SuppressWarnings("unchecked")
        Function<String, String> valueFn = mock(Function.class);
        when(valueFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        assertThat(MapUtilities.<String, String, String>indexBy(xs, keyFn, valueFn).get("foo"), is("foo"));
    }

    @Test
    void indexBy2() {
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        when(keyFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        LinkedList<String> xs = new LinkedList<String>();
        xs.add("foo");
        assertThat(MapUtilities.<String, String>indexBy(keyFn, xs).get("foo"), is("foo"));
    }

    @Test
    void indexBy1() {
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        when(keyFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        @SuppressWarnings("unchecked")
        Function<String, String> valueFn = mock(Function.class);
        when(valueFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        LinkedList<String> xs = new LinkedList<String>();
        xs.add("foo");
        @SuppressWarnings("unchecked")
        BinaryOperator<String> mergeFunction = mock(BinaryOperator.class);
        assertThat(MapUtilities.<String, String, String>indexBy(keyFn, valueFn, xs, mergeFunction).get("foo"), is("foo"));
    }

    @Test
    void countByXsIsEmpty() {
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        assertThat(MapUtilities.<String, String>countBy(keyFn, new LinkedList<String>()).isEmpty(), is(true));
    }

    @Test
    void countByXsIsNull() {
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        assertThat(MapUtilities.<String, String>countBy(keyFn, null).isEmpty(), is(true));
    }

    @Test
    void ensureNotNull() throws java.io.IOException, CloneNotSupportedException {
        assertThat(MapUtilities.<String, String>ensureNotNull(new HashMap<String, String>()), is(notNullValue()));
    }

    @Test
    void getters() {
        assertThat(MapUtilities.<String, String>ensureNotNull(null).isEmpty(), is(true));
        assertThat(MapUtilities.<String, String>maybeGet(null, "key").isPresent(), is(false));
    }

    @Test
    void isEmpty1() throws java.io.IOException, CloneNotSupportedException {
        assertThat(MapUtilities.<String, String>isEmpty(new HashMap<String, String>()), is(true));
    }

    @Test
    void isEmpty2() {
        assertThat(MapUtilities.<String, String>isEmpty(null), is(true));
    }

    @Test
    void isEmptyReturnsFalse() throws java.io.IOException, CloneNotSupportedException {
        HashMap<String, String> map = new HashMap<String, String>();
        map.put("", "foo");
        assertThat(MapUtilities.<String, String>isEmpty(map), is(false));
    }

    @Test
    void maybeGet() throws java.io.IOException, CloneNotSupportedException {
        assertThat(MapUtilities.<String, String>maybeGet(new HashMap<String, String>(), "key").isPresent(), is(false));
    }

    @Test
    void groupAndThenXsIsFooReturnsFoo() {
        @SuppressWarnings("unchecked")
        Function<String, String> keyFn = mock(Function.class);
        when(keyFn.apply(Mockito.<String>any()))
            .thenReturn("foo");
        @SuppressWarnings("unchecked")
        Function<Collection<String>, String> valueFn = mock(Function.class);
        when(valueFn.apply(Mockito.<Collection<String>>any()))
            .thenReturn("foo");
        LinkedList<String> xs = new LinkedList<String>();
        xs.add("foo");
        assertThat(MapUtilities.<String, String, String>groupAndThen(keyFn, valueFn, xs).get("foo"), is("foo"));
    }

    @Test
    void transformKeys() throws java.io.IOException, CloneNotSupportedException {
        HashMap<String, String> original = new HashMap<String, String>();
        @SuppressWarnings("unchecked")
        Function<String, String> transformation = mock(Function.class);
        assertThat(MapUtilities.<String, String, String>transformKeys(original, transformation).isEmpty(), is(true));
        Mockito.verify(original).forEach(ArgumentMatchers.<BiConsumer<? super String, ? super String>>any());
    }

    @Test
    void compose() throws java.io.IOException, CloneNotSupportedException {
        HashMap<String, String> map1 = new HashMap<String, String>();
        assertThat(MapUtilities.<String, String, String>compose(map1, new HashMap<String, String>()).isEmpty(), is(true));
        Mockito.verify(map1).forEach(ArgumentMatchers.<BiConsumer<? super String, ? super String>>any());
    }
}
